---
tags: java jvm performance jit benchmark
category: programming
title: "Part 2: JIT disassembly, compressed oops and task pinning in Linux"
date: 2025-12-30 23:59:59 +05:30
---

Hello!! Welcome back!

> For those who landed here directly, this is the part 2 of the series - [Taking JVM on a performance ride (4D tensor)]({% post_url 2025-12-18-jvm-perf-4d-tensor %}). I suggest you to take a look at the intro page before reading this.

<br>

Code and results referred here are present in [mmpataki/tensor.benchmark](https://github.com/mmpataki/tensor.benchmark), you can get them and reproduce the results on your computer by -

```bash
# clone the repo, cd & pull
$ git clone https://github.com/mmpataki/tensor.benchmark; cd tensor.benchmark; git pull

# checkout the branch used for this part
$ git checkout p2-java-assembly-and-task-pinning

# build the benchmark
$ mvn clean package
```
<br>

In this part, we will check the code generated by the JIT compiler and try some optimizations based on that. JVM can print the binary code generated by these compilers using a disassembler plugin named `hsdis`. You can download it from internet or build on your own (Steps at the end)

Once you have `hsdis` in place, asking the JVM to disassemble and print the assembly is just adding a cmdline option.

```bash
java \
    -XX:+UnlockDiagnosticVMOptions \
    -XX:CompileCommand=print,com.mpataki.Tensor4DBenchmark::realTest \
    -jar target/benchmarks.jar
```

Compiler output from my machine are here
- [Last compilation done by C2](https://github.com/mmpataki/tensor.benchmark/blob/master/observations/p2-java-assembly-and-task-pinning/c2-compiled-realTest.S)
- [Full](https://github.com/mmpataki/tensor.benchmark/blob/master/observations/p2-java-assembly-and-task-pinning/compiler-output.txt)


<br>
### Reading the assembly

The assembly is too large to read in the raw format (too many brnaches), so with the help of ChatGPT I created a python script which will render it as a graph. The script can be found [here](https://github.com/mmpataki/tensor.benchmark/blob/master/tools/asm_cfg.py). To use it, run the below command and paste the output in [GraphViz online](https://dreampuf.github.io/GraphvizOnline/)

```
cat c2-compiled-realTest.S | python asm_cfg.py
```
**OR**


You can see the complete graph here - [Control-Flow-Graph-of-generated-assembly](https://dreampuf.github.io/GraphvizOnline/?engine=dot&compressed=CYSw5gTghgDgFgAgMIDEDiCDeAoBDoB2A1qBALwAqAQgNy4IED2wApggNr14DOcsLZAEaMAHgBouCAGaMCAFwJQAtgKWzG3GFADGLCXjwz53EAC8BATn0GA7iGBy4ZACwA6AKzXDIES2AnzMikoABtuFnoAXTo8ACIABhF45PiAdigLKHdnQXjgQQAmeNiOEKhBFhCyBKSU9Mzs3PyigC4DEW04MAMAUihxPpEAHRDElLSMrJy8woK2vDUANwMERIAOAAoeiBMASjFtgEY8kbG6ycaZgoA2eYRtJRgV9a3oEX2jk9Ha5PqppsKUDuACsCGwDGdfhdnO41u54td4iNYtF6DVxn9LvkAMzFUrlSrVSETBrTHHxO5LFY9Fj9MQAWkSh2cKVeml2px%2BJP%2BM2xqTuMAArrxehBBDBORjoQDsWs7txBYIVgASRK4g47CXfKWkmXaO4PGAhAyqpJiRJFV6Hdwc7XnXUzZzOEFg55czFkqTpZGouLEj0A5xQErsMoVKro%2B08-JBymMZaikwataSqNYwTOYBxhN4JnaNkgD4QQ6HYCpqEO-LuQ7Zt35o4FDUlsRrIuHbFlu0V6OCdy3dqMCDUiAWYAa0fl7np9wWO6LESDmDcBA9ERKJTxA5rjdb9dIrtTsm9rMGYBQORQQ7XBAdLorumDScBmaIu5yFjcOSi9tjo4dp-Si%2B2IghUbo6tGZ4piEKIxAgkbdum1wWCGYaEvBh4AkhtYQiIxxWo2RyHC2bZfP6gH5NcLDYbmHT4U2m6tgcLCCMMB7PvkqTAQY76fr0zEDPxAGVoIqTuCB4I0eBWIUT6sHoexImCChBIRmRwmpII1GrLh8R0Z8xFMdorFqT2awUgYVI4fWxYERARkGZ8nYmemcJvh%2BX54I59FOe65GCGscoGMCoE4VJZLANo7iyWizlHmsLDKeGRK%2BcJ8VaUyukNhq9mMY5Qk9hYXELPGdZ6cWDEfIJbF%2BRYgV4EwRqha8D5vGIhy2rFAJQOZeA8R5K78UxLH5emUBzEFIWSWm4XAAU0V%2BilPZQGsiVoZ1MzLXOUDAP4y4ZWVxwOdum6rnuI1HlAUh3CEtIrAdRG5W850AoIRUIJZeCmkR2wTtBvpwet%2BSCMh%2BJJfJfnA1pppSM4BQsk2mbPTMghXQYCpKqKo4Iz5YUAto414IaKpqiwazY0j%2BTaLOFklSaJNkzSRkU4IugGksUCeSw9lHIj1XCbNdzbcAw5YzzOPTQCwBiQYixLAAjp5EAM9uhzM2ec5LMLK7FqWu5KNiauo-VjBajBMWLemLB4qGKnJbjMxW1pP2-h%2BIDMywb1QAQWufYkUj%2BwHVtMSY7v9sVOba6LXPGRbR4sNTPCKtSruGTH9v5MxTsjr%2BOviwhcdUQYXs%2Bwg0MB-72gnbnzNSAT7204rovlXnGEzFI0uJxjisljnxwtwpUh1fXizcCECvO8mNeaTTEcTzSwBpxLbeF3gxfEyI5cBydfiL-nTSVzWM8iy7oAU5Xzpo0nfEL0xp989GldhwgIBKIKxq%2Bxvm-%2BxYcM-84hXJg1MNe%2BWJK4nh4FAIcdMRBFCAbvVuEUSxO0GjScUZ92yCx2sfIaWpAbaCvPKSB69nA4PQQnZ%2Br936lzzDg0hICyT4P1EfTGLtgF4MOEbBA6Nk7iiGvA9i%2BND6E0eMOH83kz5wxBFACS2l07aHkfNAGsd94FGDKDNayi8j4yBDPUe49c70QkeA4ew4GY6zPrieUV9u5VxLBYt6H1tJ4W2C1ZszgSL93ItoWU6VaJZX0o9HuFjjG8CodQkQ2JDH0P3s4IR9wRHfl1vPN20StFOikTIwGwB4jaEUeDSs2ggyrVUpoiKsZdFjwGjfQiZ9MxZzMXfPB8IrFd21s2bYjTSmRQcQ3JxmVyoalAGIdx4jUkRVhL46yhxbKHUCaWM%2B7gQlwDCaaSJnwz7XDiUTRJrD%2BFeOuBfPAwJpFgSXjtJ0eS8HXDUTbMGVydHhz0QNXhNSxnaGuMYxx2wzFsK6akHqXDrFtO%2BmKPZBTOK%2BOcQM7YLFhmVV%2BXI1IQ9HGJCmbZWFczPHguMTdDmBgyoYpImfNYWyEndySdHYlhyEDHMyaU4ASLLldLWDc1CJS5EsuzE8mkSZXl4LWCEoFhFJ5vIsACxYQtuB7R0laKuZMRmnR3Iq-ceCLD8gMCAAg2hj5n0yHcBqNgmouIGK1dqZ9upsyeN%2BTM44sUPygG9YEYTZFnIqPuM2C05EZGKXbM52gMi%2BNxFaG0US8HbTcrxTmdJZUdS6bkS168YZwyrr9PBIkQRgDpenHaUAmVyMEMAH1%2BSH4Fo1vGBWK4VYirwfjMtiwtaKrWdXN52h1VHLJS6veyMLB5r9fIotNamF4FluWzyVbvln2AHEkd9ax3ribUEv6ck8HAGuAOrpq660NuOnQj1Si5FnnXQeh5JjoFfxYCQnlKSV2cK%2BdnMQbIYCxrkR7ZBQzEjOEfc%2Bv1LA22ns5rCl42x2Rn0zswzm9lUVftA7e3pXl9rAafWfGG9TzS4U2Ih79XaIpSHIXenuaHmTQbeVIFeDATbIc4f6kIVDYoHMEIcK2vbsPZOcEes5rH9Um1ozpZIBQpDWRanSM1S7zbZpyexljOS60VsVSCqCe7i3SRLJJhBU7p2aznUq5ipt-pKfCtaVT7Ep0d3-eE89l7XYUynSeu9WNiNZMY8gwDIhP2YeswUOuXzo5oYw5qLDambhZ0Ogh-zHnp7h2Tu%2BvxYWxmzVg7PJWhG-Mgbi9ialZ4LxXhvJ0bogwDj9Gs3yA0oQeNhXo4x91emsnYm0EZ8iwBatccajRIoyRsTpeaia4TtpFNZKdPVyswB0ky3llp%2BTzG1P-0GxBf%2BW6tPbzQaJz1HHMwzeknU8D5nN4XuDte%2Bl7gvNwfvQ5g7T9vOQdc6d7N7hbPHZCyIFLSG4vuASzw8QoXUtZOuD0xLZMmRPYC8Z64Q9MuXmvLePLD5CtxeuBF%2B4pXQrTQq0x5b%2B6OP-PW%2BFf5zWeO4nayDrrGoeuTeM0irHTQGVDxnbJ8dStScNdSIW9R7KMfGJnduvcu7qv0pJRTvIwASVQz9jtyzIc4trHO8d%2Bz7mJd3cSw9wH1m1hvb4pdtzsWsmFVQ5957WvQfnnBzlu8%2BXHxxYsPD6jZXkc5Eqwzob3V%2Bc5oBQ1HjLJ2u1SJ8atqvWefZuWk7yCdwFxQM5kM5J1moAnpD%2B9vhkeh03kHMnbmlK4vSOD0n78eRRlZIYyCDtK7rj24goINdLPfUsdL-KZZ68F0qvpYIaPmeAMCQRRxlmGfQ8DRT0zOLFRO9RZALffb2bK756tVNFjdi0f6cp5FQPkVrq3Xxf4uy4hAn19H%2BQmPauBK96ydoeHO%2BW9x7i9oYxwIC-0v-sX6Ss1A8CzRjX6BdfrOboHF3xme%2BwUQUF%2BP05LGTOt%2BM0rKtss%2BAu6sBgBqRqrU3uImWSjsBg2yH8Sa8Mzs1mv6GaWaZyzEqQwBlOfggefgdwYO2WkO94AwMOfW9KUg1sbKFeamtBWcUc4uWSUgns3siaX828rBNBUuiWUcnS2auGLSycvKfgI%2BHGUg8Odmvc8ycWpGgsnBZ6O2ti8hgMVsR2AhLs%2B%2BpSVspm3COyqcFMVsyK8Y3K96E6YyVsMh0uvcvMGh8QZGa8Kh5clc5M1h0yzBvcpEeh1ooh1qPhdqWILAhwQ8L8b8rhm8f8MRTaPyP%2BIRHChCXeposCMKCRZILABQv2se88GRTQWRpmQs2CeRJhBQQ83ARC0ClmC8ZR8OERVCX02gt8AktR1hBQZGshp%2BGh2IcShhYere%2BReQHsb0yBbSHYOeeh2IT8tKABCCXMeBM%2BPRdW5e4BrATWFS%2BizIPhJh2IquisPyuCehsMARNiQCRx6cF6pmKKMq3uMKMAcKkxlx5SkWVkB0FUHhGhzgnCoSteoaeh7goxHaYsw%2BJhfYGScx7EfguaSxAJKxtyGilx7gCeSw3KKcHSkh2GLAr2qGwGmJ8x1wdc-R2s4eOw%2BJUJ1w1xvSoWh0eJjxV6Jh1ykyZUSYuUEhjJnCuKd0q%2BrJRK1hEKSBwJEh3RehokEJSOWJpM%2BBwxGkTuv6thI8lSeRcCJhqQnRx2DS5J5EpMfRQqoKgyWplYpM1KNxUKtJEAQyCq7J1haweG1JMW0yBpDkVUGhaUBgXJK%2BNkTpG%2BJhP8CafEsKX%2Bvp1KsxEp8xUgResJlxmQcpeqmxwKchvpgqrSwqVhGhFqMskq0qZpcq9JO6yqJhUAf6mq2qLChZJ6Yx0MsMaB2cJheeQUzqbBVWy6ehIkcp6aRcWCL%2BVcmgdZ8OMAJsw4S2GhHegpE%2B2k5RwaRYvZ1hY%2BQUeKYZ7EEZzg0prA7ycp7ydwEALAcgq5CxG5f6HOC2dCGhh%2BMm421aeh2S82la86TY6hV5pml%2B45K6MJ1Blxh6qxGhkBw6mmt52mw5V5ZGNOF5aZehr6QUV%2B2a1oe5pMcppMN5yqJ54FCeIF-5E21hUgcSz5kJDWvM75OBEZcpEZiF%2BZOmJhwQ556Fl5lx-szWFMtBAKOFi5DWJKq5tB7gTuHFwun85cqQ1we2DF8Q8upi5xQlxi5Bnk0OQxwAtBVGiOk%2Bh4KOzZYmZyWFbGX5pS6luOOE8IyQ8Igm3W4g8BWlhwCex%2BVSQ%2BEeYyWF6pEcZcm8AlDJNl2Rb6Vl5FLlpmklFBBWMltcf6VuLFpIyl7FBQ8J9BaxtcCeruOEiI%2BlcMXupqQO5E7B1KFlqCgxDF0xPFX8EZglNl2ICpuRHlgM7BEluWvQ0lWV8lNGQVUwIVUZalA2ml6cMM1KMVNE-y%2BltWiVJONlzg5lze3e3%2BDFzgdlXBjl%2BVpVgJyCKegFrV7gXlFVUllBfl7gAVClnaSltuqOBF2G7c4VYB010V3GOEZk%2Bl2QvVxlvuLZrVByXFBy2Y5Qy4poUJLM-xd141WeaGzgiIU5DFYpkFL5scsI2g8UKlK2%2B16QXF6QJWtVeAAAynIIqC0C0AQCoI4MwAAPosDyAQAACeWNjeEAEAIALAEA7FqQUgMNnCzFilCkQY7FawGlCJrO%2B1zNdwyyu5jV7NnFLValrkBgXNTNZerNDBS5kunNIQ3Ne1CCg8qQXFawf6wtPNctAUitQ8dNW1Ho9GY1EN6O7NzOYtkVAqcN1u%2B1P87FP8XFfpl8ggFa4Sng12alaq-%2BdV2QsIFQZkVth1dyWlFgCeKtstS5o4NtxiQdfuLtCU-NFtZGEdt1Lt1NMdctFgnC8dql2GhQeI9IAAfAbQgq9MUAnZnbiCULnfnUudDcXQXaXQgOXWsRmMGNXQzWovXVkgHs3X5EUnXXnQ3UhLEJ3cJP3T3RXQ1qXgPRnQXcPW3aUopBPZDQXbKSPWseMvPaPepEpMvYDP5AlIPaZNHTPdmvfnvS5Afb3dvR3ZPQpAHlvbPcDGvQ3ffbfenG6g-dvVbGXefV0v2ifXHNnV-XIqom-V0kA8-RxhJr-Soq3QA36kUpA2ktA%2BvbNmxvA2Uog2se8k3Vffsug1kuTqg5g5-Ug6AiysAxyrg7PR-QQ6Q2A9hv6shAQ96rQ2poeowyDIfX6gWmQ5w8zhw5nffQQ1w8wwIj-dgwUv2sI14qutw3Q9I5IwUqw2Iw-J%2BXw2pvECg0o9JOo0QyvRA5o%2BFBJvIxBCpqg%2Bpjo45pxaY4ZkY9JLVjI2pnYzY%2BFANqY81ao8ZtNq4%2BwzAyxmtq47wz42ppjqY5jk45Tvg-o%2BEytGEwLkzvY2TgE8Q%2BFHzqY3zjE87vEw1o7uk5BJkw7tE%2B41I2uqYzfYU0NuPaY%2BPTkyY5EwLlU2UxBPPqY-Pjk547UztC0w03fgUHk7-j0zk3E6Y-fjk4owvcZio4E29QrUMxQ9moQaY4QTk7Qb09JMs%2Bk-uaY2s105kXY6gx7CsdswUaM0kwUY44c8MciSs5kZc%2Bs3BXszc%2Bc6wLKXs0vY8ywERS85vW8zGXszGUs0Xe0-HLMzgW2Xs22ek8uVcwUeC28%2BuXs62uYxulg2M9qQi%2Bs8c2sdCYi9BZY4CxMyc8MXc4C3Ba04WnsyS28x84C0RTkyk9S2Xo8xxVC3kEyxC8yMy7JeyxC2FRy1Fdi01Royi5WG1fy-tZc6gwdaK3LfdRK-dRC1Xe016MC1DdTRK1TVKy3by%2BqxC8zby%2BrTq2S4qwKhqyldbRK9bRCwHRPQAL5AA)


> **For curious readers** - the generated assembly has too much of validation and error handling, you can take help of ChatGPT to understand it. I was really surprised when it asked me whether this was generated by JVM without even providing comments.


In this big CFG, the hotspot (our array access code) is the below sub graph.

![Tada](/images/posts/tensor-benchmark/p2/hotspot-subgraph.png)


<br>

Few notes on above graph
1. Notice the blocks - 1, 2, 3, 4. They seem to be calculating the indexes and accessing sub arrays.
2. All these blocks have index-validations so when there is a validation failure, they branch to left side blocks - 6, 7, 8, 9.
3. Block 5 is doing the real operation - access the element and add to sum variable.


<br>

## A side-note on Java pointers and object layout

### Compressed pointers
Even if we run a 64 bit JVM, by default, for small heap sizes (<32G) the references to objects are 32 bit. These are called compressed pointers. They help JVM lower the memory footprint for most applications (you can disable it too).

Compressing a pointer is as simple as shifting it left by 3 bits (shl) and expanding is multiplyng by 8 (or right shift 3 bits).

Conversion from JVM pointer to physical memory (or logical memory -- lets be aware of segmentation and paging done by OS) address is done through 
```
logical_addr = heap_base_ptr (usually r12) + pointer * 8
```

### Object layout
JVM attaches a header to every java object for its management (GC, locking, typing etc). It looks as follows
```
offset  length (bit)    note
0x0     32              mark word
0x4     32              mark word
0x8     32              class word
0xc     32              loss due to alignment
0x10    .... other object fields ....
```
If the JVM knows that there is loss due to alignment for a type, `0xc` can be used for storing fields.

You can read a lot more about this here - [https://shipilev.net/jvm/objects-inside-out](https://shipilev.net/jvm/objects-inside-out)


<br>

## Back to our assembly...

Let's look at one of the intermediate block (which accesses a sub array at some level) to understand this assembly better

```assembly
; essentially rsi = r8 - esi
; rsi is index of a sub array (you can look at the complete assembly)
0x00007a9a54b0de5c:   movslq %esi,%rdi
0x00007a9a54b0de5f:   mov    %r8,%rsi
0x00007a9a54b0de62:   sub    %rdi,%rsi

; copy the address of the sub-array's first element to esi
; r10 points to first element of parent array.
0x00007a9a54b0de65:   mov    0x10(%r10,%rsi,4),%esi

; get the array length (present at 0xc offset) and put it in edi
; note the decoding of the pointer to logical address here
0x00007a9a54b0de6a:   mov    0xc(%r12,%rsi,8),%edi

; load the address of the sub-array in to r10
0x00007a9a54b0de6f:   lea    (%r12,%rsi,8),%r10

; compare the index we are accessing (ebx) with length of the array (edi)
0x00007a9a54b0de73:   cmp    %edi,%ebx

; jump to block 8 (exception) if above or equal
0x00007a9a54b0de75:   jae    0x00007a9a54b0dee8
```

## Too much overhead for just accessing an array element. What can be done?

First thing that strikes our mind is to get rid of compressed pointers. Let's try that out first.

```bash
$ java -XX:-UseCompressedOops -jar target/benchmarks.jar 
...

Result "com.mpataki.Tensor4DBenchmark.accessTest":
  130.186 ±(99.9%) 0.749 ops/s [Average]
  (min, avg, max) = (130.009, 130.186, 130.491), stdev = 0.195
  CI (99.9%): [129.437, 130.935] (assumes normal distribution)

Benchmark                      Mode  Cnt    Score   Error  Units
Tensor4DBenchmark.accessTest  thrpt    5  130.186 ± 0.749  ops/s
```
<br>

The numbers went down. What is going on? Did JIT generate more instructions this time? Let's compare the compiled code stats. Full compilation results with -XX:-UseCompressedOops [from my machine are here](https://github.com/mmpataki/tensor.benchmark/blob/master/observations/p2-java-assembly-and-task-pinning/uncompressed-pointer-c2-compiler-realTest.S)

```
# Stats of compiled method in JVM with -XX:-UseCompressedOops
Compiled method (c2) 482  961       4       com.mpataki.Tensor4DBenchmark::realTest (59 bytes)
 total in heap  [0x000076c734b0e108,0x000076c734b0e610] = 1288
 relocation     [0x000076c734b0e1e0,0x000076c734b0e218] = 56
 main code      [0x000076c734b0e220,0x000076c734b0e5e8] = 968  <============
 stub code      [0x000076c734b0e5e8,0x000076c734b0e600] = 24
 oops           [0x000076c734b0e600,0x000076c734b0e608] = 8
 metadata       [0x000076c734b0e608,0x000076c734b0e610] = 8
 immutable data [0x000076c5e0006c00,0x000076c5e0006de8] = 488
 dependencies   [0x000076c5e0006c00,0x000076c5e0006c08] = 8
 nul chk table  [0x000076c5e0006c08,0x000076c5e0006c60] = 88
 scopes pcs     [0x000076c5e0006c60,0x000076c5e0006d10] = 176
 scopes data    [0x000076c5e0006d10,0x000076c5e0006de8] = 216

# Stats of compiled method in JVM without any flags
Compiled method (c2) 487  950       4       com.mpataki.Tensor4DBenchmark::realTest (59 bytes)
 total in heap  [0x00007a9a54b0da08,0x00007a9a54b0dfb0] = 1448
 relocation     [0x00007a9a54b0dae0,0x00007a9a54b0db18] = 56
 main code      [0x00007a9a54b0db20,0x00007a9a54b0df88] = 1128 <============
 stub code      [0x00007a9a54b0df88,0x00007a9a54b0dfa0] = 24
 oops           [0x00007a9a54b0dfa0,0x00007a9a54b0dfa8] = 8
 metadata       [0x00007a9a54b0dfa8,0x00007a9a54b0dfb0] = 8
 immutable data [0x00007a9a0832f220,0x00007a9a0832f408] = 488
 dependencies   [0x00007a9a0832f220,0x00007a9a0832f228] = 8
 nul chk table  [0x00007a9a0832f228,0x00007a9a0832f280] = 88
 scopes pcs     [0x00007a9a0832f280,0x00007a9a0832f330] = 176
 scopes data    [0x00007a9a0832f330,0x00007a9a0832f408] = 216
```

Number of instructions have reduced (see `main code`) but that hasn't improved the throughput.

<br>

## Is this due to varying system load? 

I ran the benchmark few times (w/ and w/o the flag `-XX:-UseCompressedOops`) for validation. These are the results.

```
=== compressed pointer ===
Tensor4DBenchmark.accessTest  thrpt    5  134.864 ± 1.269  ops/s
Tensor4DBenchmark.accessTest  thrpt    5  134.174 ± 4.505  ops/s
Tensor4DBenchmark.accessTest  thrpt    5  132.925 ± 3.045  ops/s

=== un-compressed pointer ===
Tensor4DBenchmark.accessTest  thrpt    5  127.246 ± 0.588  ops/s
Tensor4DBenchmark.accessTest  thrpt    5  132.426 ± 0.343  ops/s
Tensor4DBenchmark.accessTest  thrpt    5  131.920 ± 1.218  ops/s
```

Two points to note here
1. The numbers slightly went down when we are using un-compressed pointer
2. There is jitter in the benchmarking system. Even though numbers seem very nearby to distinguish, if you recall the loop in the `realTest` method - it iterates for 1_000_000 times, so the smallest differences in above numbers should matter for us. How do we eliminate these differences?

<br>

## Why performance decreased with un-compressed pointer?
I have no freaking clue. I need to experiment and figure it out. May be in subsequent episodes.

<br>

## Jitter in the system
What can we do here? Is it the system load? Is our thread is time sharing CPU core with other tasks in the system or the thread is jumping between cores (getting scheduled on different cores)?


### __Experiment 1. `taskset` and `nice`__

To isolate our benchmark from the system load, we can
- make our process high priority by setting its niceness to `-20`
- set its processor affinity to few processors (it will run on only those CPU cores; aka pinning a task to processors)


Usually a JVM has many threads. In our application, the important ones are - 2-compiler threads (in tiered mode, its the minimum) and our main thread. So lets use 4 processors for pinning our threads. We can use the below command. _([full output](https://github.com/mmpataki/tensor.benchmark/blob/master/observations/p2-java-assembly-and-task-pinning/taskset/4-procs.txt))_

```bash
$ taskset -c 2-6 \
  nice -20 \
  java -jar ./target/benchmarks.jar

# results for 3 runs
(min, avg, max) = (130.509, 130.745, 131.182), stdev = 0.271
(min, avg, max) = (128.707, 130.467, 131.601), stdev = 1.075
(min, avg, max) = (129.288, 131.815, 132.836), stdev = 1.513
```

Results are inconsistent (look at min, max and stdev). Is our main task jumping between 4 processors? Let's try with 2 processors. _([full output](https://github.com/mmpataki/tensor.benchmark/blob/master/observations/p2-java-assembly-and-task-pinning/taskset/2-procs.txt))_

```bash
$ taskset -c 5-6 nice -20 java -jar target/benchmarks.jar

# results for 3 runs
(min, avg, max) = (130.000, 130.394, 131.161), stdev = 0.455
(min, avg, max) = (127.208, 131.264, 135.267), stdev = 3.253
(min, avg, max) = (123.210, 124.443, 124.934), stdev = 0.699
```

Surprisingly the results are still inconsistent, there is still some jitter (see the stdev). We need to be sure our thread is running on a single processor all the time.

## It's time for `perf'

`perf` is a Linux tool which lets us monitor and record events (software & hardware) with their metadata. Two of the scheduler events which are interesting for us are sched_switch (triggered when scheduler switches a task) & sched_migrate_task (triggered when scheduler moves a task from one processor to other) (you can get info and the list of all events by looking at `perf list`). 

```bash
$ sudo \
  taskset -c 2-6 \
  nice -20 \
  perf record -e sched:sched_switch,sched:sched_migrate_task \
  java -jar target/benchmarks.jar
```

Post this, we need to run below command to aggregate the stats (events are dumped in to a file named `perf.data`). In below output, 1st column is number of times our thread (task) was rescheduled, x/y in col 2 is TID/PID, and 3rd column is processor id (you can also download the [perf.data](https://github.com/mmpataki/tensor.benchmark/blob/master/observations/p2-java-assembly-and-task-pinning/perf.data) file and from same dir, just run `perf sched timehist`).

``` bash
$ perf sched timehist | grep com.mpataki | awk '{printf "%s %s\n", $3, $2}' | sort | uniq -c
Samples of sched_switch event do not have callchains.
    842 com.mpataki.Ten[123747/123693] [0002]
    205 com.mpataki.Ten[123747/123693] [0003]
    396 com.mpataki.Ten[123747/123693] [0004]
   1050 com.mpataki.Ten[123747/123693] [0005]
   1180 com.mpataki.Ten[123747/123693] [0006]
    671 com.mpataki.Ten[126541/126499] [0002]
    916 com.mpataki.Ten[126541/126499] [0003]
   1172 com.mpataki.Ten[126541/126499] [0004]
    640 com.mpataki.Ten[126541/126499] [0005]
    378 com.mpataki.Ten[126541/126499] [0006]
```

#### Were there any other processes on these processors?

Looking at the some entries of type `sched_migrate_task` tells us that other processes were scheduled on these processors.

```bash
$ perf script | grep sched_migrate_task 
Thread-9  126501 [004]  5141.499049: sched:sched_migrate_task: comm=Service Thread pid=123635 prio=139 orig_cpu=5 dest_cpu=6
java  123612 [003]  5141.522494: sched:sched_migrate_task: comm=chrome pid=9037 prio=120 orig_cpu=3 dest_cpu=0
java  123612 [003]  5141.540684: sched:sched_migrate_task: comm=VM Periodic Tas pid=123620 prio=139 orig_cpu=3 dest_cpu=4
java  123612 [003]  5141.543664: sched:sched_migrate_task: comm=kworker/u48:1 pid=63632 prio=120 orig_cpu=0 dest_cpu=1
```


So our assumption was incorrect. Setting the process affinity will not make those processors exclusive to this process. It's just tells Linux to schedule the process always on these CPUs.

What would you do if you wanted Linux to never schedule other processes on these processors?


**In the next episode of this series, we will see the answer to this and dig further deep into reducing the noise on the bechmarking machine. Also I will also try to introduce you to a surprise which stumped me while experimenting with this benchmark.**

**<center>Until then, enjoy the rest of the 2025!</center>**

<br><br><br>

### Steps to build `hsdis`

- Build JDK. Steps here, you need to change a little - [https://github.com/openjdk/jdk24u/blob/master/doc/building.md](https://github.com/openjdk/jdk24u/blob/master/doc/building.md)

- Download binutils source and keep them somewhere and provide path while configuring
  ``` bash
  bash configure --with-hsdis=binutils --with-binutils-src=/path/to/binutils-2.45.1
  ```

- make

- Copy the `.so` file to the `$JAVA_HOME/lib/server`

